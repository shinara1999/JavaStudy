package com.sist.main;
/*
 * 		객체지향의 3대 특성 => 문법사항이 아니다, 권장사항임
 * 		---------------
 * 		class Window extends JFrame => 재사용기법 => 상속
 * 			=> 변경 사항이 있는 경우
 * 		class Window
 * 		{
 * 			JFrame f=new JFrame() => 재사용 기법 => 포함 => 변경 사항이 없는 경우
 * 		}									  
 * 		=> 웹 / 스프링 => 상속이 거의 없다. => 포함
 * 
 * 		1. 캡슐화 : 데이터 보호
 * 				  멤버변수 => private로 은닉화 => 기능 설정을 통해 접근
 * 											  -------
 * 												멤버변수 : 저장/읽기
 * 												----------------
 * 													   ㅣ
 * 												getter / setter
 * 				  데이터를 감추고 메소드를 통해서 접근하는 방식 
 * 		2. 상속 / 포함 : 기존의 클래스를 재사용하는 목적
 * 			상속
 * 			---
 * 			1) 목적
 * 				= 재사용 (신뢰성이 뛰어나다 , 개발 속도가 빠르다.)
 * 				= 유지보수를 쉽게 만든다.
 * 				= 중복을 최대한 제거할 수 있다.
 * 				= 통일성있는 코드 제작 가능
 * 				= 단점 : 실행속도가 늦다.
 * 						------ 최적화
 * 				= 장점 : 적은 양의 코드로 새로운 클래스 작성
 * 				
 * 				class A extends JFrame
 * 				{
 * 				}
 * 
 * 				코드를 공통적으로 관리하기 때문에 여러 코드를 추가 , 변경이 용이
 * 										   ------------   ----------------
 * 											  오버로딩		  오버라이딩
 * 		  2) 작성방법
 * 				확장한다 => 기존의 클래스를 확장해서 새로운 클래스 제작
 * 				extends
 * 				=> class Parent
 * 				   class Child extends Parent
 * 		
 * 				=> 단점 : 단일 상속만 가능하다.
 * 		  3)
 * 				1. 생성자 , 초기화블록 상속이 안된다.
 * 				   상속받은 클래스의 객체 생성시에 => 상속받은 클래스가 먼더 메모리 할당을 한다.
 * 				class A
 *				{
 *					int a, b;
 *					String s;
 *					public A() => 생략되어 있음. (자동추가)
 *					{
 *					}
 *				}
 *				
 *				class B extends A
 *				{
 *					int c, d;
 *					public B() => 생략되어 있음. (자동추가)
 *					{
 *						super() => 상속받은 클래스의 생성자 호출
 *					}
 *				}
 *	
 *				B b=new B();
 *				
 *				Stack => 메모리에서 처리 (할당, 해제)
 *				Heap => 실제 데이터 저장 (프로그래머)
 *			=> 모든 클래스의 상위 클래스 (최상위 클래스)
 *				=> Object
 *			=> private : 상속은 된다, but 접근이 불가능하다.
 *											 -------- protected
 *			=> 상속 => 상위 클래스 => super
 *					  자신 클래스 => this
 *		 	=> 상속을 내리는 클래스 : 상속받은 클래스에 접근이 불가능
 *			   상속을 받는 클래스 : 자신+상속을 내리는 클래스까지 접근 가능	
 *							   this+super
 * 		3. 다형성 => 필요시에
 * 		   => 변경해야 된다. => 오버라이딩
 * 		   => 추가해서 사용 => 오버로딩
 * 		[접근지정어] 리턴형 메소드명(매개변수)
 * 		{
 * 
 * 		}
 * 		--------------------------------------
 * 			         오버라이딩			오버로딩
 * 		--------------------------------------
 * 		상태			상속					같은 클래스 안에서
 * 					=> 상속 없이 오버라이딩 가능
 * 					=> 익명의 클래스
 * 		메소드명		동일					동일
 * 		매개변수		동일					갯수나 데이터형이 다르다.
 * 		리턴형		동일					관계없다.
 * 		접근지정어		축소(X), 확대(O)		관계없다.
 * 			private < default < protected < public
 * 		
 * 			=> 예)
 * 				void aaa()
 * 
 * 				=> protected void aaa()
 * 				   public void aaa()
 * 				=> 메소드는 다른 클래스와 연결
 * 				   ----- public
 * 			=> modify : 기존의 기능 변경 , New => 새로운 기능 추가
 * 			=> 면접의 기술 => 정의를 내린다 => 부연설명
 * 			=> 객체지향프로그램의 객체란
 * 							현실세계를 특성화 => 추상화 => 단순화
 * 							-------------
 * 		----------------------------------------------------
 * 		상속 예외조건 => static : 공통으로 사용이 가능
 * 					  생송자 / 초기화 블록
 * 					  private : 상속은 된다 => 접근을 할 수 없다.
 * 		주의점)
 * 			접근지정어
 * 			클래스 => [접근지정어] class 클래스명
 * 			메소드 => [접근지정어] 리턴형 메소드명(매개변수)
 * 			멤버변수 => [접근지정어] 데이터형 변수명
 * 			생성자 => [접근지정어] 클래스명()
 * 			지역변수 , 매개변수	: 접근지정어를 사용할 수 없다.
 * 							  static 사용할 수 없다.
 * 							  => final 만 사용이 가능 => 상수형
 * 			메소드
 * 				멤버메소드 : static , 멤버변수를 사용할 수 있다.
 * 				static 메소드 : static만 자유롭게 사용 가능하다.
 * 						만약 => 멤버변수, 멤버메소드를 사용할 때는 반드시 객체 생성 후에 사용한다.
 * 				class A
 * 				{																																																																												
 * 					private int a;
 * 					static int b;
 * 					public void aaa();
 * 					{
 * 						a, b, bbb()
 * 					}
 * 					public static void bbb()
 * 					{
 * 						b => 사용 가능
 * 						a, aaa() => 사용 불가
 * 						A aa=new A();
 * 						aa.a
 * 						aa.aaa()
 * 					}		
 * 				}
 * 			초기화 블록 : 자동 호출
 * 				= 인스턴스 블록
 * 					{	
 * 						static , 메버변수를 초기화할 수 있다.
 * 					}
 * 				= static 블록
 * 					static {
 * 						static 변수만 초기화 가능
 * 					}
 * 			변수에 대한 초기화
 * 				1) 명시적 초기화 private in a=10;
 * 				2) 초기화 블록 : static변수 초기화
 * 				   => static은 생성자를 호출할 필요가 없다. => 자동 메모리 할당
 * 				3) 생성자	 : 인스턴스 변수 초기화
 * 				   => 인스턴스는 반드시 생성자를 호출해야 저장
 * 				   => new() 생성자
 * 				   => 시작과 동시 처리
 * 				---------------- 클래스 영역은 선언만 가능 => 구현	
 * 				구현 => 연산처리 , 제어문 , 파일 읽기 , 오라클 데이터 읽기...
 */
class A
{
	int a;

//	public A() { => 생략
//		super();
//	}
	
}
class B extends A
{
	int c;

//	public B() { => 생략
//		super();
//	}
	
}
public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
